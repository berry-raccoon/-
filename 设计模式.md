# 知识点

[设计模式](https://www.runoob.com/design-pattern/factory-pattern.html)

《大话设计模式》:star:每天一章

[黑马程序员2017C++设计模式（已完结）](https://www.bilibili.com/video/BV1KW411t7FV?spm_id_from=333.999.0.0)



什么是单例？

c++多线程，多进程编程？

| 日期 | 学习点        | 简介                                                         |
| ---- | ------------- | ------------------------------------------------------------ |
| 0406 | 简单工厂模式  | 实例化类。从设计一个计算器出发，**封装**为显示界面和处理函数，**继承**则是拓展加减乘除该些功能，从而实现**多态**。**简单工厂模式**则是用一个单独的类来做创造实例的过程，比如我想要加号，那么我根据简单工厂模式来实例化加，用一个switch来选择生成不同的类 。在继承过程中**虚函数**的用法此外需要复习，此外介绍了**UML类图**。(图中实线箭头代表关联，简单工厂中实例化运算类）<br /><img src="D:\桌面\刷题攻略\编程练习\剑指offer\images\简单工厂.png" style="zoom:50%;" /> |
| 0407 | 策略模式      | 封装算法（类似于一个锦囊Strategy基类，里面包含各种方案，然后Context类则相当于一个锦囊的清单，构造锦囊（可用简单工厂模式），并实现锦囊中的某个方法）。从设计收银软件出发，收银软件需要考虑商场的促销互动，如打折、满减等，该些活动可以封装继承为一个个算法，因此可以用Context类去管理这些算法，Context类的功能是实例类和调用方法，与简单工厂模式相互结合。 |
| 0408 | 单一职责原则  | 就一个类而言，应该仅有一个引起它变化的原因。从设计方块游戏出发，可以设计两个大类，分别是界面类和游戏逻辑类，而不是将两个任务混合在一起。 |
| 0412 | 开放-封闭原则 | 开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。比如0406中计算器的设计，在功能上应该创建一个虚类，通过封装等操作拓展功能但是不修改已经完成的类。 |
| 0413 | 依赖倒转原则  | A.高层模块不应该依赖低层模块。两个都应该依赖抽象。B.**抽象不应该依赖细节。细节应该依赖抽象**。(大白话：谁也不要依靠谁，除了约定的接口）<br />思考电脑的部件，是一个强内聚、松耦合的结构，因为主板提供了多个接口，接口的规格又是固定的，比如当内存损坏时，可以通过替换内存实现修改电脑的目的。<br />里氏代换原则：子类必须能够替换掉它们的父类。<br />![](D:\桌面\刷题攻略\编程练习\剑指offer\images\依赖倒转原则.png) |
| 0414 | 装饰模式      | 给一个对象按顺序添加多个功能。就像穿衣服一样，内衣和外衣要按一定的顺序穿。因此会生成一个对象链（套娃），有点像外衣是为了装饰内衣，而内衣和外衣是为了装饰人。<br />当系统需要新功能的时候，是向旧的类中添加新的代码。这些**新加的代码通常装饰了原有类的核心职责或主要行为**，但这种做法的问题在于，它们在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度，就像你起初的那个‘人’类，而这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。而装饰模式却提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。<br/>“那么装饰模式的优点我总结下来就是，把类中的装饰功能从类中搬移去除，这样可以简化原有的类。”<br/>“是的，这样做更大的好处就是有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。” |
| 0415 | 代理模式      | 为其他对象提供一种代理以控制这个对象的访问。从追女生送男生东西的事情出发，比如我想送kk东西，但是我不能直接去理工，我就拖老李帮我转交。图中subject是一个接口类，包含我送花，送娃娃这些动作，RealSubject和Proxy都要继承这个接口，因为我和老李都进行了这些动作，不同的是Proxy老李依赖于我的行为，在老李那生成我的实例。Client就是kk啦。<br /><img src="D:\桌面\刷题攻略\编程练习\剑指offer\images\代理模式.png" style="zoom:60%;" /> |
| 0417 | 工厂方法模式  | 根据**依赖倒转原则**，我们把工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后，所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，变成了一个工厂抽象接口和多个具体生成对象的工厂，于是我们要增加‘求M数的N次方’的功能时，就不需要更改原有的工厂类了，只需要增加此功能的运算类和相应的工厂类就可以了。我感觉工厂方法克服了简单工厂违背**开放封闭原则**的缺点，又保持了封装对象创建过程的优点。”。<br /><img src="D:\桌面\刷题攻略\编程练习\剑指offer\images\工厂方法.png" style="zoom:67%;" /> |
| 0418 | 原型模式      | 拷贝原型对象。就像复制简历一样，你需要一份真实写好的简历作为一个原型，然后通过打印机对原型进行拷贝。**如果字段是值类型的，则对该字段执行逐位复制，如果字段是引用类型，则复制引用但不复制引用的对象：因此，原始对象及其复本引用同一对象。**这种方法的缺点为，当我这一简历复印件给同学使用，但他们的工作经历要稍作修改，由于“原始对象及其复本引用同一对象”造成最后修改的结果影响到了我的结果，因此在工作经历这一类中也要进行深拷贝，其具体方法为工作经历类继承"ICloneable"。<br /><img src="D:\桌面\刷题攻略\编程练习\剑指offer\images\原型模式.png" style="zoom:60%;" /> |
| 0419 | 模板方法模式  | 定义一个操作中算法的骨架，将一些步骤通过虚函数的方式延迟到子类。比如试卷模板，每个同学的试卷是相同的，但是答案会不同，因此试卷是一个父类模板，答案是子类函数。AbstractClass是抽象类，其实也就是一抽象模板，定义并实现了一个模版方法。这个模版方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。ConcreteClass，实现父类所定义的一个或多个抽象方法。每一个AbstractClass都可以有任意多个ConcreteClass与之对应，而每一个ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。<br />![](D:\桌面\刷题攻略\编程练习\剑指offer\images\模板方法.png) |
| 0420 | 迪米特法则    | 如果两个类不必彼此直接通讯，那么两个类就不应当直接的相互作用。在类的结构设计上，应当尽量降低成员的访问权限。 |
| 0421 | 状态模式      | 是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。当然，如果这个状态判断很简单，那就没必要用‘状态模式’了。**可以消除庞大的条件分支语句**<br />![](D:\桌面\刷题攻略\编程练习\剑指offer\images\状态模式.png) |
| 0422 | 外观模式      | 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。就像股民买卖基金一样，把自己的钱投入基金，基金的管理者可以将钱去买卖房地产、股票等，股民只要看住基金即可。股民就是用于，基金和基金管理者就是外观类，给股民提供了更便捷的接口，并且股民根本不需要知道股票一等的存在。<br />![](D:\桌面\刷题攻略\编程练习\剑指offer\images\外观模式.png) |
| 0425 | 建造者模式    | 建造小人，虽然小人的矮胖有差异，但是小人都必须有头有身体，以及两手两脚。**建造小人的‘过程’是稳定的，都需要头身手脚，而具体建造的’细节‘是不同的，有胖有瘦有高有矮**。如果我们用了建造者模式，那么用户就只需指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需知道了。<br />首先是建造一个抽象类，把过程给稳定住（用虚函数？）。让瘦子类、胖子类等去继承这个抽象类。再建造一个指挥家类来控制建造过程，用户来告诉指挥家，我需要怎样的人。<br />![](D:\桌面\刷题攻略\编程练习\剑指offer\images\建造者模式.png) |
| 0427 | 观察者模式    | 其实感觉像被观察者，比如实验室的同学会根据秦老师是否来而改变状态。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个Subject对象。这个Subject对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。Subject类把所有对观察者对象引用保存在一个聚集里，在Subject内部状态改变时，给所有登记过的观察者发送通知。<br />适用于**当一个对象改变需要同时改变其他对象。**比如你在IDE里，点击运行程序，某些窗口会改变<br /><img src="D:\桌面\刷题攻略\编程练习\剑指offer\images\观察者模式.png" style="zoom:60%;" /> |
| 0428 | 抽象工厂模式  | **工厂：用来实例化对象。**SQL与Access创建和删除的用户方式不同，那怎样才能轻松切换？先新建一个工厂的接口，分别用来实例话SQL和Access类，由于其操作不同，因此再创建一个接口，通过函数重写实现多态。抽象工厂模式（Abstract Factory），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。（更简单的凡是切换不同的版本）<br /><img src="D:\桌面\刷题攻略\编程练习\剑指offer\images\抽象工厂模式.png" style="zoom:60%;" /> |
| 0430 | 适配器模式    | 从原始的适配器去理解：有些国家用110V电压，而我们国家用的是220V，但我们的电器，比如笔记本电脑是不能什么电压都能用的，但国家不同，电压可能不相同也是事实，于是就用一个电源适配器，只要是电，不管多少伏，都能把电源变成需要的电压，这就是电源适配器的作用。在软件设计中，系统数据和行为都正确，但接口不符时，就考虑用适配器。(一般在设计阶段不用，而在多个产品维护过程中需要）<br /><img src="D:\桌面\刷题攻略\编程练习\剑指offer\images\适配器模式.png" style="zoom:60%;" /> |
| 0501 | 备忘录模式    | 在玩游戏的时候存在一个存档，那在程序中可以怎么设计？<br /><img src="D:\桌面\刷题攻略\编程练习\剑指offer\images\备忘录模式.png" style="zoom:60%;" /><br />‘游戏角色’类其实就是一个Originator，依赖于Memento来存储一些备份信息，而这些备份信息由Caretaker来进行管理。该方法的缺点为很消耗内存。 |



# code

```c++

```


# 4. 心得
