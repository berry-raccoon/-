# 合并区间

```c++
    unordered_map<int, int> L(300000), R(300000);
	// 1. 记录左边界与右边界
	for (int i = 1; i <= n; i ++ )
	{
        int a;
        scanf("%d", &a);
        R[a] = i;
        if (!L.count(a)) L[a] = i;
    }
		
	// 2. 记录所有区间，并排序
    vector<pair<int, int>> q;
    for (auto& [k, v]: L)  {
        q.push_back({L[k], R[k]});
    }

    sort(q.begin(), q.end());

	// 3. 合并区间
    int cnt = 0, st = -1, ed = -1;
    for (int i = 0; i < q.size(); i ++ ) {
        if (q[i].first <= ed) ed = max(ed, q[i].second);
        else
        {
            cnt ++ ;
            st = q[i].first, ed = q[i].second;
        }
    }


```

# 1005.K次取反后最大化的数组和

```c++
class Solution {
public:
    // 1. 类内定义谓词
    static bool cmp(int a, int b) {
        return abs(a) > abs(b);
    }
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), cmp);
        // 2. 从前向后遍历，遇到负数将其变为正数，同时K--
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] < 0 && k > 0) {
                nums[i] *= -1;
                k--;
            }
        }
        // 3. 如果K还大于0，那么反复转变数值最小的元素，将K用完
        if (k % 2 == 1) nums[nums.size() - 1] *= -1;
        // 4. 求和
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        return sum;
    }
};
```

