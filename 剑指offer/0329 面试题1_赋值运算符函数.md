# 运算符的重载

[黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难](https://www.bilibili.com/video/BV1et411b73Z?p=121)

[《剑指Offer》面试题1：赋值运算符函数](https://www.cnblogs.com/littlecurl/p/operator.html)

## **加号**运算符重载

[实验平台](https://b5c07b2d.lightly.teamcode.com/)

```c++
#include <bits/types/struct_tm.h>
#include <iostream>
using namespace std;

class Person {
public:
  int a;
  int b;
  Person() {}
  Person(int a, int b) {
    this->a = a;
    this->b = b;
  }
  // 2. 可以采用成员函数的方式 本质是：Person p3 = p1.operator+(p2)
  // Person operator+(const Person& p) {
  //   Person tmp;
  //   tmp.a = this->a + p.a;
  //   tmp.b = this->b + p.b;
  //   return tmp;
  // }
};
// 3. 我也可以采用全局函数的方式实现
Person operator+(const Person& p1, const Person& p2)  {
  Person tmp;
  tmp.a = p1.a + p2.a;
  tmp.b = p1.b + p2.b;
  return tmp;
}
int main() {
    Person p1(10, 5);
    Person p2(6, 7);
    Person p3 = p1 + p2;  // 1. 明确目的是想两个类相加
    cout << p3.a << " " << p3.b << endl;
}
```

## **左移**运算符重载

```c++
# include <iostream>
using namespace std;
class Person {
public:
    int m_a;
    int m_b;
    // 2. 开始书写成员函数形式，那这个函数返回的是什么呢，不知道的时候可以先写void
    // void operator<<(cout)  这样的简化版本是 p<< cout，明显错误，那么用全局函数形式
};
 //  3. 全局函数形式，简化可以为cout << p，此处涉及两个知识点：引用：不创建新的变量形式，起别名；
 // cout的数据类型，是输入输出流格式
// void operator<<(ostream &cout, Person &p) {
//     cout << p.m_a << " " << p.m_b;
// }
// 5. cout << p的返回值还是一个cout,涉及到链式编程思想
ostream & operator<<(ostream &cout, Person &p) {
    cout << p.m_a << " " << p.m_b;
    return cout;
}
int main() {
    Person p;
    p.m_a = 5;
    p.m_b = 10;
    cout << p;  // 1. 我想要这样的形式，可是这样会报错，
                // 此时考虑运算符的重载，运算符的重载方式有成员函数形式，也有全局函数形式
                // 首先尝试成员函数形式
    // 4. 我想要尝试这种形式,原先写的运算符重载会失效       
    cout << p << endl; 
     
    return 0;
}
```

## **递增**运算符重载

(前置递增与后置递增)：

```c++
# include <iostream>
using namespace std;
class MyInteger {
    friend ostream & operator<<(ostream &cout, MyInteger &myint);
private:
    int mNum;
public:
    MyInteger() {
        mNum = 0;
    }
    //++前置 为什么返回引用？如果不加引用返回的是一个新的变量，而引用返回是原来的变量，
    // 可以尝试++(++myint)
    MyInteger& operator++() {
        mNum++;
        return *this; //解引用
    }

    //后置++ int是一个占位参数，可以区分前置和后置递增
    MyInteger operator++(int) {
        MyInteger temp = *this;
        mNum++;
        return temp;  // 返回的是局部对象，返回时会被释放，所以不能引用
    }
};
ostream & operator<<(ostream &cout, MyInteger &myint) {
    cout << myint.mNum;
    return cout;
}
int main() {
    MyInteger myint;
    cout << myint << endl;  // 0
    cout << ++myint << endl;  // 1
    cout << myint++ << endl; // 1
    cout << myint << endl; // 2
    return 0;
}
```

## 小节

1. 什么时候用友元？（1.3）

   当一个全局函数需要访问一个类中的私有变量时，可以将全局函数设置为友元。

2. 什么时候有引用？（1.3）

   引用是给变量起别名。返回时候需要引用是原变量进行操作，而不是返回一个新变量，可以对一个数据一直进行操作。

3. 什么是`*this`（1.3）

   这是一个类的解引用，当需要返回一个类或是类的引用时，可以`return *this`。

# 题目
# code

```c++
```
# 4. 心得
