# 知识点

[设计模式](https://www.runoob.com/design-pattern/factory-pattern.html)

《大话设计模式》:star:每天一章

[黑马程序员2017C++设计模式（已完结）](https://www.bilibili.com/video/BV1KW411t7FV?spm_id_from=333.999.0.0)



什么是单例？

c++多线程，多进程编程？

| 日期 | 学习点        | 简介                                                         |
| ---- | ------------- | ------------------------------------------------------------ |
| 0406 | 简单工厂模式  | 实例化类。从设计一个计算器出发，**封装**为显示界面和处理函数，**继承**则是拓展加减乘除该些功能，从而实现**多态**。**简单工厂模式**则是用一个单独的类来做创造实例的过程，比如我想要加号，那么我根据简单工厂模式来实例化加。在继承过程中**虚函数**的用法此外需要复习，此外介绍了**UML类图**。(图中实线箭头代表关联，简单工厂中实例化运算类）<br /><img src="D:\桌面\刷题攻略\Carl\剑指offer\images\简单工厂.png" style="zoom:50%;" /> |
| 0407 | 策略模式      | 封装算法（类似于一个锦囊Strategy基类，里面包含各种方案，然后Context类则相当于一个锦囊的清单，构造锦囊（可用简单工厂模式），并实现锦囊中的某个方法）。从设计收银软件出发，收银软件需要考虑商场的促销互动，如打折、满减等，该些活动可以封装继承为一个个算法，因此可以用Context类去管理这些算法，Context类的功能是实例类和调用方法，与简单工厂模式相互结合。 |
| 0408 | 单一职责原则  | 就一个类而言，应该仅有一个引起它变化的原因。从设计方块游戏出发，可以设计两个大类，分别是界面类和游戏逻辑类，而不是将两个任务混合在一起。 |
| 0412 | 开放-封闭原则 | 开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。比如0406中计算器的设计，在功能上应该创建一个虚类，通过封装等操作拓展功能但是不修改已经完成的类。 |
| 0413 | 依赖倒转原则  | A.高层模块不应该依赖低层模块。两个都应该依赖抽象。B.抽象不应该依赖细节。细节应该依赖抽象。(大白话：谁也不要依靠谁，除了约定的接口）<br />思考电脑的部件，是一个强内聚、松耦合的结构，因为主板提供了多个接口，接口的规格又是固定的，比如当内存损坏时，可以通过替换内存实现修改电脑的目的。<br />里氏代换原则：子类必须能够替换掉它们的父类。<br />![](D:\桌面\刷题攻略\Carl\剑指offer\images\依赖倒转原则.png) |
| 0414 | 装饰模式      | 给一个对象按顺序添加多个功能。就像穿衣服一样，内衣和外衣要按一定的顺序穿。因此会生成一个对象链（套娃），有点像外衣是为了装饰内衣，而内衣和外衣是为了装饰人。<br />当系统需要新功能的时候，是向旧的类中添加新的代码。这些**新加的代码通常装饰了原有类的核心职责或主要行为**，但这种做法的问题在于，它们在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度，就像你起初的那个‘人’类，而这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。而装饰模式却提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。<br/>“那么装饰模式的优点我总结下来就是，把类中的装饰功能从类中搬移去除，这样可以简化原有的类。”<br/>“是的，这样做更大的好处就是有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。” |
| 0415 | 代理模式      | 为其他对象提供一种代理以控制这个对象的访问。从追女生送男生东西的事情出发，比如我想送kk东西，但是我不能直接去理工，我就拖老李帮我转交。图中subject是一个接口类，包含我送花，送娃娃这些动作，RealSubject和Proxy都要继承这个接口，因为我和老李都进行了这些动作，不同的是Proxy老李依赖于我的行为，在老李那生成我的实例。Client就是kk啦。<br /><img src="D:\桌面\刷题攻略\Carl\剑指offer\images\代理模式.png" style="zoom:60%;" /> |
| 0417 | 工厂方法模式  | 根据**依赖倒转原则**，我们把工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后，所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，变成了一个工厂抽象接口和多个具体生成对象的工厂，于是我们要增加‘求M数的N次方’的功能时，就不需要更改原有的工厂类了，只需要增加此功能的运算类和相应的工厂类就可以了。我感觉工厂方法克服了简单工厂违背**开放封闭原则**的缺点，又保持了封装对象创建过程的优点。”。<br />![](D:\桌面\刷题攻略\Carl\剑指offer\images\工厂方法.png) |
|      |               |                                                              |
|      |               |                                                              |
|      |               |                                                              |



# code

```c++

```


# 4. 心得
