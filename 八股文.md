# 简述strcpy、sprintf 与memcpy 的区别

网址：https://www.iamshuaidi.com/2415.html

日期：20220329

补充：

| 函数名  | 形式                                                   | 说明                                                   | 网址                                                        |
| ------- | ------------------------------------------------------ | ------------------------------------------------------ | ----------------------------------------------------------- |
| strcpy  | `char *strcpy(char *dest, const char *src)`            | 符串src复制到dest                                      | https://www.runoob.com/cprogramming/c-function-strcpy.html  |
| sprintf | `int sprintf(char *str, const char *format, ...)`      | 发送格式化输出到 **str** 所指向的字符串                | https://www.runoob.com/cprogramming/c-function-sprintf.html |
| memcpy  | `void *memcpy(void *str1, const void *str2, size_t n)` | 从存储区 **str2** 复制 **n** 个字节到存储区 **str1**。 | https://www.runoob.com/cprogramming/c-function-memcpy.html  |

# 对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？（inline)

宏定义：复制 - 只保留文本

内联函数inline: 复制 - 保留原格式

| 普通函数 | inline内联函数                                               |
| -------- | ------------------------------------------------------------ |
| 函数调用 | 调用的地方进行代码展开，程序运行更快                         |
|          | 编译器会进行语法安全检查或数据类型转换                       |
|          | 内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大 |
|          | 修改内联函数，那么所有调用该函数的代码文件都需要重新编译     |

[C++中的inline用法](https://www.cnblogs.com/fnlingnzb-learner/p/6423917.html)

# 回调是什么？学习python transitions

# 什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？

智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用`delete`删除指针所指向的内存空间。

智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。

| 指针类型                           | 特定 |
| ---------------------------------- | ---- |
| std::auto_ptr                      |      |
| std::unique_ptr - single ownership |      |
| std::shared_ptr - shared ownership |      |
| std::weak_ptr - temp/no ownership  |      |

Defined in <memory> header

# shared_ptr是如何实现的？

# 简述队列和栈的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是“后进先出”。
「注意」：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表。它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。

# 悬挂指针与野指针有什么区别？

| 名称             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| 悬挂指针         | 指针所指向的内存空间被释放，但它仍指向该空间                 |
| 野指针(不能访问) | 未初始化的指针；指针变量指向非法的内存空间。`//指针变量p指向内存地址编号为0x1100的空间int * p = (int *)0x1100;//访问野指针报错cout << *p << endl;` |
| 空指针(不能访问) | 指针变量指向内存中编号为0的空间；用于初始化指针变量；空指针指向的内存是不可以访问的。`int * p = NULL;` |

- 指针的使用

```c++
# include <iostream>
using namespace std;
int main() {
    //1、指针的定义（定义）
    int a = 10; //定义整型变量a
    //指针定义语法： 数据类型 * 变量名 ;
    int * p;
    //2、指针变量赋值（建立关系）
    p = &a; //指针指向变量a的地址
    cout << &a << endl; //打印数据a的地址
    cout << p << endl; //打印指针变量p
    //3、指针的使用(解引用)
    //通过*操作指针变量指向的内存
    cout << "*p = " << *p << endl;
    system("pause");
    return 0;
}
```

- 指针的内存

指针类型在32位操作系统下是4个字节；

指针类型在64位操作系统下是8个字节；

[30. 如何避免“野指针”](https://link.zhihu.com/?target=https%3A//www.iamshuaidi.com/%3Fp%3D2462)

# 设置地址为0x67a9 的整型变量的值为0xaa66

补充：内存地址和变量大小的关系

```c++
int b[2] = {0, 1};  // int占据4个字节， 一个字节8位，那么最大值应该是2^31 - 1(0X7FFFFFFF/INT_MAX),最小值为-2^31

printf("b0的地址是（用十六进制表示）%p\n", b);   		// 0x7ffebbb5391c  //这里的单位是字节
printf("b1的地址是（用十六进制表示）%p\n", b + 1);		// 0x7ffebbb53920  (+ 4)
```

```c++
int * ptr;
ptr = (int *) 0x67a9;
*ptr = 0xaa66;
```

**「注意」**：这道题就是强制类型转换的典型例子，绝大部份情况下，地址长度和整型数据的长度是一样的(此时的整型指的是 long)， 即一个整型数据可以强制转换成地址指针类型，只要有意义即可。

# 请解析(\*(void (\*)( ) )0)( )的含义

[(*(void (*) ()) 0) ();](https://blog.csdn.net/changexhao/article/details/82556711)

[(*(void(*)())0)(); 是什么意思](https://blog.csdn.net/han8040laixin/article/details/78281884?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6.pc_relevant_default&utm_relevant_index=10)

[经典面试题一：解释一下：(*(void(*fun)(void))0)(); 是什么？](https://blog.csdn.net/qq_38290047/article/details/105294148?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-8.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-8.pc_relevant_default&utm_relevant_index=12)

# strlen\str.size()\sizeof()

