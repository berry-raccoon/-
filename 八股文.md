# 简述strcpy、sprintf 与memcpy 的区别

网址：https://www.iamshuaidi.com/2415.html

日期：20220329

补充：

| 函数名  | 形式                                                   | 说明                                                   | 网址                                                        |
| ------- | ------------------------------------------------------ | ------------------------------------------------------ | ----------------------------------------------------------- |
| strcpy  | `char *strcpy(char *dest, const char *src)`            | 符串src复制到dest                                      | https://www.runoob.com/cprogramming/c-function-strcpy.html  |
| sprintf | `int sprintf(char *str, const char *format, ...)`      | 发送格式化输出到 **str** 所指向的字符串                | https://www.runoob.com/cprogramming/c-function-sprintf.html |
| memcpy  | `void *memcpy(void *str1, const void *str2, size_t n)` | 从存储区 **str2** 复制 **n** 个字节到存储区 **str1**。 | https://www.runoob.com/cprogramming/c-function-memcpy.html  |

# 对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？（inline)

宏定义：复制 - 只保留文本

内联函数inline: 复制 - 保留原格式

| 普通函数 | inline内联函数                                               |
| -------- | ------------------------------------------------------------ |
| 函数调用 | 调用的地方进行代码展开，程序运行更快                         |
|          | 编译器会进行语法安全检查或数据类型转换                       |
|          | 内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大 |
|          | 修改内联函数，那么所有调用该函数的代码文件都需要重新编译     |

[C++中的inline用法](https://www.cnblogs.com/fnlingnzb-learner/p/6423917.html)

# 回调是什么？学习python transitions

# 什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？

智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用`delete`删除指针所指向的内存空间。

智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。

| 指针类型                           | 特定 |
| ---------------------------------- | ---- |
| std::auto_ptr                      |      |
| std::unique_ptr - single ownership |      |
| std::shared_ptr - shared ownership |      |
| std::weak_ptr - temp/no ownership  |      |

Defined in <memory> header

# shared_ptr是如何实现的？

# 简述队列和栈的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是“后进先出”。
「注意」：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表。它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。

# 悬挂指针与野指针有什么区别？

| 名称             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| 悬挂指针         | 指针所指向的内存空间被释放，但它仍指向该空间                 |
| 野指针(不能访问) | 未初始化的指针；指针变量指向非法的内存空间。`//指针变量p指向内存地址编号为0x1100的空间int * p = (int *)0x1100;//访问野指针报错cout << *p << endl;` |
| 空指针(不能访问) | 指针变量指向内存中编号为0的空间；用于初始化指针变量；空指针指向的内存是不可以访问的。`int * p = NULL;` |

- 指针的使用

```c++
# include <iostream>
using namespace std;
int main() {
    //1、指针的定义（定义）
    int a = 10; //定义整型变量a
    //指针定义语法： 数据类型 * 变量名 ;
    int * p;
    //2、指针变量赋值（建立关系）
    p = &a; //指针指向变量a的地址
    cout << &a << endl; //打印数据a的地址
    cout << p << endl; //打印指针变量p
    //3、指针的使用(解引用)
    //通过*操作指针变量指向的内存
    cout << "*p = " << *p << endl;
    system("pause");
    return 0;
}
```

- 指针的内存

指针类型在32位操作系统下是4个字节；

指针类型在64位操作系统下是8个字节；

